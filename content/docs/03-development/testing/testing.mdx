---
title: Testing
description: Comprehensive testing strategies and practices
icon: TestTube
---

## Testing in DevSecOps

Testing ensures code quality, reliability, and security. A comprehensive testing strategy includes multiple test types at different levels.

## Testing Pyramid

```mermaid
graph TD
    A[UI Tests] --> B[Integration Tests]
    B --> C[Unit Tests]
    
    style A fill:#FF6B6B
    style B fill:#FFD93D
    style C fill:#6BCB77
```

<Callout type="info">
The testing pyramid emphasizes:
- **More unit tests** (fast, isolated, cheap)
- **Fewer integration tests** (moderate speed, more complex)
- **Minimal UI/E2E tests** (slow, expensive, fragile)
</Callout>

## Unit Testing

### JavaScript/TypeScript (Jest)

```package-install
jest @types/jest --save-dev
```

```typescript
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function divide(a: number, b: number): number {
  if (b === 0) {
    throw new Error('Division by zero');
  }
  return a / b;
}

// math.test.ts
import { add, divide } from './math';

describe('Math utilities', () => {
  describe('add', () => {
    it('should add two positive numbers', () => {
      expect(add(2, 3)).toBe(5);
    });

    it('should handle negative numbers', () => {
      expect(add(-2, 3)).toBe(1);
    });
  });

  describe('divide', () => {
    it('should divide two numbers', () => {
      expect(divide(10, 2)).toBe(5);
    });

    it('should throw error on division by zero', () => {
      expect(() => divide(10, 0)).toThrow('Division by zero');
    });
  });
});
```

**Jest Configuration:**

```javascript
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  coverageDirectory: 'coverage',
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/**/*.test.{ts,tsx}'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

### Python (pytest)

```package-install
pytest pytest-cov
```

```python
# calculator.py
class Calculator:
    def add(self, a: float, b: float) -> float:
        return a + b
    
    def divide(self, a: float, b: float) -> float:
        if b == 0:
            raise ValueError("Division by zero")
        return a / b

# test_calculator.py
import pytest
from calculator import Calculator

class TestCalculator:
    @pytest.fixture
    def calc(self):
        return Calculator()
    
    def test_add(self, calc):
        assert calc.add(2, 3) == 5
        assert calc.add(-2, 3) == 1
    
    def test_divide(self, calc):
        assert calc.divide(10, 2) == 5
    
    def test_divide_by_zero(self, calc):
        with pytest.raises(ValueError, match="Division by zero"):
            calc.divide(10, 0)
    
    @pytest.mark.parametrize("a,b,expected", [
        (10, 2, 5),
        (20, 4, 5),
        (100, 10, 10),
    ])
    def test_divide_parametrized(self, calc, a, b, expected):
        assert calc.divide(a, b) == expected
```

**pytest.ini:**

```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --cov=src
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=80
```

### Go

```go
// math.go
package math

func Add(a, b int) int {
    return a + b
}

func Divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// math_test.go
package math

import (
    "testing"
)

func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive numbers", 2, 3, 5},
        {"negative numbers", -2, 3, 1},
        {"zeros", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d", 
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}

func TestDivide(t *testing.T) {
    result, err := Divide(10, 2)
    if err != nil {
        t.Errorf("Unexpected error: %v", err)
    }
    if result != 5 {
        t.Errorf("Divide(10, 2) = %d; want 5", result)
    }
}

func TestDivideByZero(t *testing.T) {
    _, err := Divide(10, 0)
    if err == nil {
        t.Error("Expected error for division by zero")
    }
}
```

## Integration Testing

### API Testing with Supertest

```typescript
import request from 'supertest';
import { app } from '../src/app';
import { setupTestDatabase, teardownTestDatabase } from './helpers';

describe('User API', () => {
  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await teardownTestDatabase();
  });

  describe('POST /users', () => {
    it('should create a new user', async () => {
      const response = await request(app)
        .post('/users')
        .send({
          name: 'John Doe',
          email: 'john@example.com'
        })
        .expect(201);

      expect(response.body).toMatchObject({
        name: 'John Doe',
        email: 'john@example.com'
      });
      expect(response.body.id).toBeDefined();
    });

    it('should reject invalid email', async () => {
      await request(app)
        .post('/users')
        .send({
          name: 'John Doe',
          email: 'invalid-email'
        })
        .expect(400);
    });
  });

  describe('GET /users/:id', () => {
    it('should retrieve existing user', async () => {
      const createResponse = await request(app)
        .post('/users')
        .send({ name: 'Jane Doe', email: 'jane@example.com' });

      const userId = createResponse.body.id;

      const response = await request(app)
        .get(`/users/${userId}`)
        .expect(200);

      expect(response.body).toMatchObject({
        name: 'Jane Doe',
        email: 'jane@example.com'
      });
    });

    it('should return 404 for non-existent user', async () => {
      await request(app)
        .get('/users/999999')
        .expect(404);
    });
  });
});
```

### Database Testing

```python
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from myapp.models import Base, User
from myapp.database import get_db

@pytest.fixture(scope='function')
def db_session():
    # Create test database
    engine = create_engine('sqlite:///:memory:')
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    session = Session()
    
    yield session
    
    session.close()

def test_create_user(db_session):
    user = User(name='John Doe', email='john@example.com')
    db_session.add(user)
    db_session.commit()
    
    retrieved = db_session.query(User).filter_by(email='john@example.com').first()
    assert retrieved is not None
    assert retrieved.name == 'John Doe'

def test_user_unique_email(db_session):
    user1 = User(name='John', email='john@example.com')
    user2 = User(name='Jane', email='john@example.com')
    
    db_session.add(user1)
    db_session.commit()
    
    db_session.add(user2)
    with pytest.raises(Exception):  # IntegrityError
        db_session.commit()
```

## End-to-End Testing

### Playwright

```package-install
@playwright/test --save-dev
```

```typescript
// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Login Flow', () => {
  test('should login successfully', async ({ page }) => {
    await page.goto('http://localhost:3000/login');
    
    await page.fill('input[name="email"]', 'user@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page).toHaveURL('http://localhost:3000/dashboard');
    await expect(page.locator('h1')).toContainText('Dashboard');
  });

  test('should show error for invalid credentials', async ({ page }) => {
    await page.goto('http://localhost:3000/login');
    
    await page.fill('input[name="email"]', 'wrong@example.com');
    await page.fill('input[name="password"]', 'wrongpassword');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('.error')).toContainText('Invalid credentials');
  });
});
```

**playwright.config.ts:**

```typescript
import { PlaywrightTestConfig } from '@playwright/test';

const config: PlaywrightTestConfig = {
  testDir: './e2e',
  timeout: 30000,
  retries: process.env.CI ? 2 : 0,
  use: {
    baseURL: 'http://localhost:3000',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { browserName: 'chromium' },
    },
    {
      name: 'firefox',
      use: { browserName: 'firefox' },
    },
    {
      name: 'webkit',
      use: { browserName: 'webkit' },
    },
  ],
};

export default config;
```

### Cypress

```package-install
cypress --save-dev
```

```javascript
// cypress/e2e/login.cy.js
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('/login');
  });

  it('should login successfully', () => {
    cy.get('input[name="email"]').type('user@example.com');
    cy.get('input[name="password"]').type('password123');
    cy.get('button[type="submit"]').click();
    
    cy.url().should('include', '/dashboard');
    cy.get('h1').should('contain', 'Dashboard');
  });

  it('should show error for invalid credentials', () => {
    cy.get('input[name="email"]').type('wrong@example.com');
    cy.get('input[name="password"]').type('wrongpassword');
    cy.get('button[type="submit"]').click();
    
    cy.get('.error').should('contain', 'Invalid credentials');
  });
});
```

## Test Coverage

```bash
# JavaScript/TypeScript
npm test -- --coverage

# Python
pytest --cov=src --cov-report=html

# Go
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# Java
mvn test jacoco:report
```

**Coverage Report Example:**

```bash
---------- coverage: platform linux, python 3.11 -----------
Name                      Stmts   Miss  Cover
---------------------------------------------
src/__init__.py               0      0   100%
src/calculator.py            12      0   100%
src/database.py              45      3    93%
src/api.py                   67      8    88%
---------------------------------------------
TOTAL                       124     11    91%
```

## Mocking and Stubbing

### JavaScript (Jest)

```typescript
// userService.ts
export class UserService {
  constructor(private api: ApiClient) {}

  async getUser(id: string): Promise<User> {
    return await this.api.get(`/users/${id}`);
  }
}

// userService.test.ts
import { UserService } from './userService';
import { ApiClient } from './apiClient';

jest.mock('./apiClient');

describe('UserService', () => {
  let service: UserService;
  let mockApi: jest.Mocked<ApiClient>;

  beforeEach(() => {
    mockApi = new ApiClient() as jest.Mocked<ApiClient>;
    service = new UserService(mockApi);
  });

  it('should fetch user by id', async () => {
    const mockUser = { id: '1', name: 'John' };
    mockApi.get.mockResolvedValue(mockUser);

    const user = await service.getUser('1');

    expect(user).toEqual(mockUser);
    expect(mockApi.get).toHaveBeenCalledWith('/users/1');
  });
});
```

### Python (unittest.mock)

```python
from unittest.mock import Mock, patch
import pytest
from myapp.services import UserService
from myapp.api import ApiClient

class TestUserService:
    def test_get_user(self):
        # Create mock
        mock_api = Mock(spec=ApiClient)
        mock_api.get.return_value = {'id': '1', 'name': 'John'}
        
        # Inject mock
        service = UserService(mock_api)
        user = service.get_user('1')
        
        assert user['name'] == 'John'
        mock_api.get.assert_called_once_with('/users/1')
    
    @patch('myapp.services.ApiClient')
    def test_get_user_with_patch(self, MockApiClient):
        mock_api = MockApiClient.return_value
        mock_api.get.return_value = {'id': '1', 'name': 'John'}
        
        service = UserService(mock_api)
        user = service.get_user('1')
        
        assert user['name'] == 'John'
```

## Performance Testing

### Artillery

```yaml
# load-test.yml
config:
  target: "http://localhost:3000"
  phases:
    - duration: 60
      arrivalRate: 10
      name: "Warm up"
    - duration: 120
      arrivalRate: 50
      name: "Sustained load"
    - duration: 60
      arrivalRate: 100
      name: "Peak load"

scenarios:
  - name: "User flow"
    flow:
      - get:
          url: "/"
      - post:
          url: "/api/login"
          json:
            email: "user@example.com"
            password: "password123"
      - get:
          url: "/api/dashboard"
```

```bash
# Run load test
artillery run load-test.yml
```

### k6

```javascript
// load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '1m', target: 10 },
    { duration: '2m', target: 50 },
    { duration: '1m', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'],
    http_req_failed: ['rate<0.01'],
  },
};

export default function () {
  const res = http.get('http://localhost:3000/api/users');
  
  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(1);
}
```

## CI/CD Integration

```yaml
name: Test Suite

on: [push, pull_request]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/lcov.info

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run integration tests
        env:
          DATABASE_URL: postgres://postgres:postgres@localhost:5432/test
        run: npm run test:integration

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
```

## Test Best Practices

<Callout type="info">
**AAA Pattern**: Arrange, Act, Assert

```typescript
test('should calculate total with tax', () => {
  // Arrange
  const price = 100;
  const taxRate = 0.08;
  
  // Act
  const total = calculateTotal(price, taxRate);
  
  // Assert
  expect(total).toBe(108);
});
```
</Callout>

### Testing Guidelines

<Steps>
  <Step>**Isolated**: Tests should not depend on each other</Step>
  <Step>**Fast**: Unit tests should run in milliseconds</Step>
  <Step>**Repeatable**: Same results every time</Step>
  <Step>**Self-validating**: Pass or fail, no manual checks</Step>
  <Step>**Timely**: Write tests as you develop</Step>
</Steps>

## Next Steps

<Cards>
  <Card title="Code Quality" href="/docs/dev/code-quality" />
  <Card title="CI/CD" href="/docs/cicd" />
  <Card title="Version Control" href="/docs/dev/version-control" />
</Cards>
